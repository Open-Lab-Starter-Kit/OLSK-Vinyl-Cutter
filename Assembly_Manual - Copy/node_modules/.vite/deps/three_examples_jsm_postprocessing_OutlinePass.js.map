{
  "version": 3,
  "sources": ["../../three/examples/jsm/postprocessing/OutlinePass.js"],
  "sourcesContent": ["import {\n\tAdditiveBlending,\n\tColor,\n\tDoubleSide,\n\tMatrix4,\n\tMeshDepthMaterial,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass OutlinePass extends Pass {\n\n\tconstructor( resolution, scene, camera, selectedObjects ) {\n\n\t\tsuper();\n\n\t\tthis.renderScene = scene;\n\t\tthis.renderCamera = camera;\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\t\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\n\t\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\n\t\tthis.edgeGlow = 0.0;\n\t\tthis.usePatternTexture = false;\n\t\tthis.edgeThickness = 1.0;\n\t\tthis.edgeStrength = 3.0;\n\t\tthis.downSampleRatio = 2;\n\t\tthis.pulsePeriod = 0;\n\n\t\tthis._visibilityCache = new Map();\n\n\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\tconst resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tconst resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new MeshDepthMaterial();\n\t\tthis.depthMaterial.side = DoubleSide;\n\t\tthis.depthMaterial.depthPacking = RGBADepthPacking;\n\t\tthis.depthMaterial.blending = NoBlending;\n\n\t\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y );\n\t\tthis.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tconst MAX_EDGE_THICKNESS = 4;\n\t\tconst MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = 1;\n\t\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ 'kernelRadius' ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t\t// copy material\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new Color();\n\t\tthis.tempPulseColor2 = new Color();\n\t\tthis.textureMatrix = new Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tconst type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t\tthis.depthMaterial.dispose();\n\t\tthis.prepareMaskMaterial.dispose();\n\t\tthis.edgeDetectionMaterial.dispose();\n\t\tthis.separableBlurMaterial1.dispose();\n\t\tthis.separableBlurMaterial2.dispose();\n\t\tthis.overlayMaterial.dispose();\n\t\tthis.materialCopy.dispose();\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\t\tthis.renderTargetDepthBuffer.setSize( width, height );\n\n\t\tlet resx = Math.round( width / this.downSampleRatio );\n\t\tlet resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ 'texSize' ].value.set( resx, resy );\n\n\t}\n\n\tchangeVisibilityOfSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t}\n\n\tchangeVisibilityOfNonSelectedObjects( bVisible ) {\n\n\t\tconst cache = this._visibilityCache;\n\t\tconst selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tconst selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\t\t// only meshes and sprites are supported by OutlinePass\n\n\t\t\t\tlet bFound = false;\n\n\t\t\t\tfor ( let i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\tconst selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( bFound === false ) {\n\n\t\t\t\t\tconst visibility = object.visible;\n\n\t\t\t\t\tif ( bVisible === false || cache.get( object ) === true ) {\n\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.set( object, visibility );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints || object.isLine ) {\n\n\t\t\t\t// the visibilty of points and lines is always set to false in order to\n\t\t\t\t// not affect the outline computation\n\n\t\t\t\tif ( bVisible === true ) {\n\n\t\t\t\t\tobject.visible = cache.get( object ); // restore\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache.set( object, object.visible );\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t}\n\n\tupdateTextureMatrix() {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tconst oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\tconst currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'cameraNearFar' ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'depthTexture' ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ 'textureMatrix' ].value = this.textureMatrix;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\t\t\tthis._visibilityCache.clear();\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tconst scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'texSize' ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'visibleEdgeColor' ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ 'hiddenEdgeColor' ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'kernelRadius' ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'colorTexture' ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ 'direction' ].value = OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ 'maskTexture' ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture1' ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeTexture2' ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ 'patternTexture' ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeStrength' ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ 'edgeGlow' ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ 'usePatternTexture' ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tgetPrepareMaskMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'depthTexture': { value: null },\n\t\t\t\t'cameraNearFar': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'textureMatrix': { value: null }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t}\n\n\tgetEdgeDetectionMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'visibleEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t'hiddenEdgeColor': { value: new Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetSeperableBlurMaterial( maxRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'MAX_RADIUS': maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'kernelRadius': { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetOverlayMaterial() {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t'maskTexture': { value: null },\n\t\t\t\t'edgeTexture1': { value: null },\n\t\t\t\t'edgeTexture2': { value: null },\n\t\t\t\t'patternTexture': { value: null },\n\t\t\t\t'edgeStrength': { value: 1.0 },\n\t\t\t\t'edgeGlow': { value: 1.0 },\n\t\t\t\t'usePatternTexture': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n}\n\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { OutlinePass };\n"],
  "mappings": "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",
  "names": ["camera"]
}
