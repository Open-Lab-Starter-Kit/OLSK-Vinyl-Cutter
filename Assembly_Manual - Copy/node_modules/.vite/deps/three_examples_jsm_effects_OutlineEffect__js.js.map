{
  "version": 3,
  "sources": ["../../three/examples/jsm/effects/OutlineEffect.js"],
  "sourcesContent": ["import {\n\tBackSide,\n\tColor,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils\n} from 'three';\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * const effect = new OutlineEffect( renderer );\n * let renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ],\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nclass OutlineEffect {\n\n\tconstructor( renderer, parameters = {} ) {\n\n\t\tthis.enabled = true;\n\n\t\tconst defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\t\tconst defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\t\tconst defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\t\tconst defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t\t// object.material.uuid -> outlineMaterial or\n\t\t// object.material[ n ].uuid -> outlineMaterial\n\t\t// save at the outline material creation and release\n\t\t// if it's unused removeThresholdCount frames\n\t\t// unless keepAlive is true.\n\t\tconst cache = {};\n\n\t\tconst removeThresholdCount = 60;\n\n\t\t// outlineMaterial.uuid -> object.material or\n\t\t// outlineMaterial.uuid -> object.material[ n ]\n\t\t// save before render and release after render.\n\t\tconst originalMaterials = {};\n\n\t\t// object.uuid -> originalOnBeforeRender\n\t\t// save before render and release after render.\n\t\tconst originalOnBeforeRenders = {};\n\n\t\t//this.cache = cache;  // for debug\n\n\t\tconst uniformsOutline = {\n\t\t\toutlineThickness: { value: defaultThickness },\n\t\t\toutlineColor: { value: defaultColor },\n\t\t\toutlineAlpha: { value: defaultAlpha }\n\t\t};\n\n\t\tconst vertexShader = [\n\t\t\t'#include <common>',\n\t\t\t'#include <uv_pars_vertex>',\n\t\t\t'#include <displacementmap_pars_vertex>',\n\t\t\t'#include <fog_pars_vertex>',\n\t\t\t'#include <morphtarget_pars_vertex>',\n\t\t\t'#include <skinning_pars_vertex>',\n\t\t\t'#include <logdepthbuf_pars_vertex>',\n\t\t\t'#include <clipping_planes_pars_vertex>',\n\n\t\t\t'uniform float outlineThickness;',\n\n\t\t\t'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n\t\t\t'\tfloat thickness = outlineThickness;',\n\t\t\t'\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n\t\t\t'\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\t'\tvec4 norm = normalize( pos - pos2 );',\n\t\t\t'\treturn pos + norm * thickness * pos.w * ratio;',\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <uv_vertex>',\n\n\t\t\t'\t#include <beginnormal_vertex>',\n\t\t\t'\t#include <morphnormal_vertex>',\n\t\t\t'\t#include <skinbase_vertex>',\n\t\t\t'\t#include <skinnormal_vertex>',\n\n\t\t\t'\t#include <begin_vertex>',\n\t\t\t'\t#include <morphtarget_vertex>',\n\t\t\t'\t#include <skinning_vertex>',\n\t\t\t'\t#include <displacementmap_vertex>',\n\t\t\t'\t#include <project_vertex>',\n\n\t\t\t'\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n\t\t\t'\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n\t\t\t'\t#include <logdepthbuf_vertex>',\n\t\t\t'\t#include <clipping_planes_vertex>',\n\t\t\t'\t#include <fog_vertex>',\n\n\t\t\t'}',\n\n\t\t].join( '\\n' );\n\n\t\tconst fragmentShader = [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_fragment>',\n\t\t\t'#include <logdepthbuf_pars_fragment>',\n\t\t\t'#include <clipping_planes_pars_fragment>',\n\n\t\t\t'uniform vec3 outlineColor;',\n\t\t\t'uniform float outlineAlpha;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <clipping_planes_fragment>',\n\t\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t\t'\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t'\t#include <encodings_fragment>',\n\t\t\t'\t#include <fog_fragment>',\n\t\t\t'\t#include <premultiplied_alpha_fragment>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' );\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new ShaderMaterial( {\n\t\t\t\ttype: 'OutlineEffect',\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\t\tUniformsLib[ 'displacementmap' ],\n\t\t\t\t\tuniformsOutline\n\t\t\t\t] ),\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: BackSide\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\t\tlet data = cache[ originalMaterial.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tdata = {\n\t\t\t\t\tmaterial: createMaterial(),\n\t\t\t\t\tused: true,\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t\t}\n\n\t\t\tdata.used = true;\n\n\t\t\treturn data.material;\n\n\t\t}\n\n\t\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\t\tconst outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\t\treturn outlineMaterial;\n\n\t\t}\n\n\t\tfunction isCompatible( object ) {\n\n\t\t\tconst geometry = object.geometry;\n\t\t\tlet hasNormals = false;\n\n\t\t\tif ( object.geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\thasNormals = geometry.attributes.normal !== undefined;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thasNormals = true; // the renderer always produces a normal attribute for Geometry\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\n\n\t\t}\n\n\t\tfunction setOutlineMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t\t}\n\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\t\tobject.onBeforeRender = onBeforeRender;\n\n\t\t}\n\n\t\tfunction restoreOriginalMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t\t}\n\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t\t}\n\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\n\n\t\t\tconst originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t\t// just in case\n\t\t\tif ( originalMaterial === undefined ) return;\n\n\t\t\tupdateUniforms( material, originalMaterial );\n\n\t\t}\n\n\t\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.displacementMap ) {\n\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\t\tif ( material.name === 'invisible' ) return;\n\n\t\t\tconst outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.fog = originalMaterial.fog;\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\t\tmaterial.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t\t\tif ( originalMaterial.clippingPlanes ) {\n\n\t\t\t\tmaterial.clipping = true;\n\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\n\n\t\t\t}\n\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\n\n\t\t}\n\n\t\tfunction cleanupCache() {\n\n\t\t\tlet keys;\n\n\t\t\t// clear originialMaterials\n\t\t\tkeys = Object.keys( originalMaterials );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// clear originalOnBeforeRenders\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// remove unused outlineMaterial from cache\n\t\t\tkeys = Object.keys( cache );\n\n\t\t\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tconst key = keys[ i ];\n\n\t\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache[ key ].used = false;\n\t\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( this.enabled === false ) {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = this.autoClear;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\tthis.renderOutline( scene, camera );\n\n\t\t};\n\n\t\tthis.renderOutline = function ( scene, camera ) {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\tconst currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n\t\t\tconst currentSceneBackground = scene.background;\n\t\t\tconst currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\t\tscene.matrixWorldAutoUpdate = false;\n\t\t\tscene.background = null;\n\t\t\trenderer.autoClear = false;\n\t\t\trenderer.shadowMap.enabled = false;\n\n\t\t\tscene.traverse( setOutlineMaterial );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\t\tcleanupCache();\n\n\t\t\tscene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n\t\t\tscene.background = currentSceneBackground;\n\t\t\trenderer.autoClear = currentAutoClear;\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t\t};\n\n\t\t/*\n\t\t * See #9918\n\t\t *\n\t\t * The following property copies and wrapper methods enable\n\t\t * OutlineEffect to be called from other *Effect, like\n\t\t *\n\t\t * effect = new StereoEffect( new OutlineEffect( renderer ) );\n\t\t *\n\t\t * function render () {\n\t\t *\n\t \t * \teffect.render( scene, camera );\n\t\t *\n\t\t * }\n\t\t */\n\t\tthis.autoClear = renderer.autoClear;\n\t\tthis.domElement = renderer.domElement;\n\t\tthis.shadowMap = renderer.shadowMap;\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn renderer.getPixelRatio();\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\trenderer.setPixelRatio( value );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn renderer.getSize( target );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\trenderer.setSize( width, height, updateStyle );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\trenderer.setViewport( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\trenderer.setScissor( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\trenderer.setScissorTest( boolean );\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t};\n\n\t}\n\n}\n\nexport { OutlineEffect };\n"],
  "mappings": "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",
  "names": ["renderer"]
}
